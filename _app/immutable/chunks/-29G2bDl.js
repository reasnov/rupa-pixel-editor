class v{static toSVG(e,c,a,r="transparent"){let h=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${e} ${c}" shape-rendering="crispEdges">`;r!=="transparent"&&(h+=`<rect width="${e}" height="${c}" fill="${r}" />`);const f=new Array(a.length).fill(!1);for(let t=0;t<c;t++)for(let s=0;s<e;s++){const l=t*e+s,n=a[l];if(n===null||f[l])continue;const g=this.findCluster(s,t,e,c,a,f);this.greedyRectMerge(g,e).forEach(o=>{h+=`<rect x="${o.x}" y="${o.y}" width="${o.w}" height="${o.h}" fill="${n}" />`})}return h+="</svg>",h}static findCluster(e,c,a,r,h,f){const t=h[c*a+e],s=new Set,l=[[e,c]];for(f[c*a+e]=!0,s.add(c*a+e);l.length>0;){const[n,g]=l.shift(),i=[[n+1,g],[n-1,g],[n,g+1],[n,g-1]];for(const[o,u]of i)if(o>=0&&o<a&&u>=0&&u<r){const x=u*a+o;!f[x]&&h[x]===t&&(f[x]=!0,s.add(x),l.push([o,u]))}}return s}static greedyRectMerge(e,c){const a=[],r=new Set,h=Array.from(e).sort((f,t)=>f-t);for(const f of h){if(r.has(f))continue;const t=f%c,s=Math.floor(f/c);let l=1;for(;e.has(s*c+(t+l))&&!r.has(s*c+(t+l));)l++;let n=1,g=!0;for(;g;){const i=s+n;for(let o=t;o<t+l;o++){const u=i*c+o;if(!e.has(u)||r.has(u)){g=!1;break}}g&&n++}a.push({x:t,y:s,w:l,h:n});for(let i=s;i<s+n;i++)for(let o=t;o<t+l;o++)r.add(i*c+o)}return a}static async toRaster(e,c,a,r,h="png",f="transparent"){const t=document.createElement("canvas"),s=Math.max(1,Math.round(e*r)),l=Math.max(1,Math.round(c*r));t.width=s,t.height=l;const n=t.getContext("2d");if(!n)throw new Error("Could not get canvas context");n.imageSmoothingEnabled=!1,f!=="transparent"?(n.fillStyle=f,n.fillRect(0,0,s,l)):h==="jpg"&&(n.fillStyle="#ffffff",n.fillRect(0,0,s,l)),a.forEach((i,o)=>{if(i===null)return;const u=o%e,x=Math.floor(o/e);n.fillStyle=i,n.fillRect(Math.floor(u*r),Math.floor(x*r),Math.ceil(r),Math.ceil(r))});const g=h==="jpg"?"image/jpeg":`image/${h}`;return t.toDataURL(g,.9)}static toAnimatedSVG(e,c,a,r,h="transparent"){const f=(a.length/r).toFixed(2);let t=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${e} ${c}" shape-rendering="crispEdges">`;return h!=="transparent"&&(t+=`<rect width="${e}" height="${c}" fill="${h}" />`),a.forEach((s,l)=>{const n=(l/r).toFixed(2);t+=`<g class="frame" style="animation: fade ${f}s step-end infinite; animation-delay: ${n}s; opacity: ${l===0?1:0}">`;const g=new Array(s.length).fill(!1);for(let i=0;i<c;i++)for(let o=0;o<e;o++){const u=i*e+o,x=s[u];if(x===null||g[u])continue;const p=this.findCluster(o,i,e,c,s,g);this.greedyRectMerge(p,e).forEach(y=>{t+=`<rect x="${y.x}" y="${y.y}" width="${y.w}" height="${y.h}" fill="${x}" />`})}t+="</g>"}),t+=`<style>
            @keyframes fade {
                0%, ${100/a.length}% { opacity: 1; }
                ${100/a.length+.01}%, 100% { opacity: 0; }
            }
            .frame { pointer-events: none; }
        </style>`,t+="</svg>",t}static async toWebM(e,c,a,r,h,f="transparent"){const t=document.createElement("canvas"),s=Math.round(e*r),l=Math.round(c*r);t.width=s,t.height=l;const n=t.getContext("2d");n.imageSmoothingEnabled=!1;const g=t.captureStream(h),i=new MediaRecorder(g,{mimeType:"video/webm"}),o=[];return i.ondataavailable=u=>o.push(u.data),new Promise(u=>{i.onstop=()=>u(new Blob(o,{type:"video/webm"})),i.start();let x=0;const p=()=>{if(x>=a.length){i.stop();return}f!=="transparent"?(n.fillStyle=f,n.fillRect(0,0,s,l)):n.clearRect(0,0,s,l),a[x].forEach((d,y)=>{if(d===null)return;const m=y%e,$=Math.floor(y/e);n.fillStyle=d,n.fillRect(Math.floor(m*r),Math.floor($*r),Math.ceil(r),Math.ceil(r))}),x++,setTimeout(p,1e3/h)};p()})}}export{v as ExportEngine};
