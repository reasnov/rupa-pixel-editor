import{_ as F}from"./B78w-WDr.js";import{C as v,P as B}from"./HfP9W3HF.js";class C{static toSVG(n,h,r,l="transparent",e=!1){let p=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${n} ${h}" shape-rendering="crispEdges">`;if(l!=="transparent"&&(p+=`<rect width="${n}" height="${h}" fill="${l}" />`),e)r.forEach((f,c)=>{if(f===0)return;const t=v.uint32ToHex(f),a=c%n,o=Math.floor(c/n);p+=`<rect x="${a}" y="${o}" width="1" height="1" fill="${t}" stroke="rgba(0,0,0,0.15)" stroke-width="0.05" />`});else{const f=new Map;for(let c=0;c<r.length;c++){const t=r[c];if(t===0)continue;const a=v.uint32ToHex(t);f.has(a)||f.set(a,new Set),f.get(a).add(c)}f.forEach((c,t)=>{const a=B.traceCluster(c,n);a&&(p+=`<path d="${a}" fill="${t}" />`)})}return p+="</svg>",p}static async toRaster(n,h,r,l,e="png",p="transparent",f=!1){const c=document.createElement("canvas"),t=Math.max(1,Math.round(n*l)),a=Math.max(1,Math.round(h*l));c.width=t,c.height=a;const o=c.getContext("2d");if(!o)throw new Error("Could not get canvas context");o.imageSmoothingEnabled=!1,p!=="transparent"?(o.fillStyle=p,o.fillRect(0,0,t,a)):e==="jpg"&&(o.fillStyle="#ffffff",o.fillRect(0,0,t,a)),r.forEach((w,M)=>{if(w===0)return;const x=v.uint32ToHex(w),m=M%n,g=Math.floor(M/n),u=Math.floor(m*l),y=Math.floor(g*l),i=Math.ceil(l),d=Math.ceil(l);o.fillStyle=x,o.fillRect(u,y,i,d),f&&(o.strokeStyle="rgba(0, 0, 0, 0.15)",o.lineWidth=1,o.strokeRect(u+.5,y+.5,i-1,d-1))});const s=e==="jpg"?"image/jpeg":`image/${e}`;return c.toDataURL(s,.9)}static toAnimatedSVG(n,h,r,l,e="transparent",p=!1){const f=l.reduce((o,s)=>o+s,0),c=(f/1e3).toFixed(3);let t=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${n} ${h}" shape-rendering="crispEdges">`;e!=="transparent"&&(t+=`<rect width="${n}" height="${h}" fill="${e}" />`);let a=0;return r.forEach((o,s)=>{const w=(a/f*100).toFixed(3),M=l[s],x=((a+M)/f*100).toFixed(3),m=`rupa-frame-${s}`;if(t+=`<g class="${m}" style="opacity: 0; visibility: hidden; animation: ${m} ${c}s step-end infinite;">`,p)o.forEach((g,u)=>{if(g===0)return;const y=v.uint32ToHex(g),i=u%n,d=Math.floor(u/n);t+=`<rect x="${i}" y="${d}" width="1" height="1" fill="${y}" stroke="rgba(0,0,0,0.15)" stroke-width="0.05" />`});else{const g=new Map;for(let u=0;u<o.length;u++){const y=o[u];if(y===0)continue;const i=v.uint32ToHex(y);g.has(i)||g.set(i,new Set),g.get(i).add(u)}g.forEach((u,y)=>{const i=B.traceCluster(u,n);i&&(t+=`<path d="${i}" fill="${y}" />`)})}t+="</g>",t+=`<style>
                @keyframes ${m} {
                    0%, ${w}% { opacity: 0; visibility: hidden; }
                    ${w}%, ${x}% { opacity: 1; visibility: visible; }
                    ${x}%, 100% { opacity: 0; visibility: hidden; }
                }
            </style>`,a+=M}),t+="</svg>",t}static async toVideo(n,h,r,l,e,p="webm",f="transparent",c=!1){const t=document.createElement("canvas"),a=Math.round(n*e),o=Math.round(h*e);t.width=a,t.height=o;const s=t.getContext("2d",{alpha:!1});s.imageSmoothingEnabled=!1;const w=p==="mp4"&&MediaRecorder.isTypeSupported("video/mp4;codecs=h264")?"video/mp4;codecs=h264":"video/webm;codecs=vp8",M=t.captureStream(30),x=new MediaRecorder(M,{mimeType:w,videoBitsPerSecond:8e6}),m=[];return x.ondataavailable=g=>{g.data.size>0&&m.push(g.data)},new Promise((g,u)=>{x.onstop=()=>{const i=new Blob(m,{type:w});g(i)},x.onerror=i=>u(i),x.start();const y=i=>{s.fillStyle=f==="transparent"?"#ffffff":f,s.fillRect(0,0,a,o);const d=r[i];for(let $=0;$<d.length;$++){const R=d[$];if(R===0)continue;const k=v.uint32ToHex(R),P=$%n,T=Math.floor($/n),S=Math.floor(P*e),E=Math.floor(T*e),b=Math.ceil(e),H=Math.ceil(e);s.fillStyle=k,s.fillRect(S,E,b,H),c&&(s.strokeStyle="rgba(0, 0, 0, 0.15)",s.lineWidth=1,s.strokeRect(S+.5,E+.5,b-1,H-1))}};(async()=>{await new Promise(i=>setTimeout(i,200));for(let i=0;i<r.length;i++)y(i),await new Promise(d=>setTimeout(d,l[i]));await new Promise(i=>setTimeout(i,500)),x.stop(),M.getTracks().forEach(i=>i.stop())})()})}static async toGIF(n,h,r,l,e,p="transparent",f=!1){const{GifWriter:c}=await F(async()=>{const{GifWriter:m}=await import("./CHXe66Ai.js");return{GifWriter:m}},[],import.meta.url),t=Math.round(n*e),a=Math.round(h*e),o=document.createElement("canvas");o.width=t,o.height=a;const s=o.getContext("2d",{alpha:!0});s.imageSmoothingEnabled=!1;const w=new Uint8Array(r.length*t*a*2),M=new c(w,t,a,{loop:0});for(let m=0;m<r.length;m++){s.clearRect(0,0,t,a),p!=="transparent"&&(s.fillStyle=p,s.fillRect(0,0,t,a));const g=r[m];for(let d=0;d<g.length;d++){const $=g[d];if($===0)continue;const R=v.uint32ToHex($),k=d%n,P=Math.floor(d/n),T=Math.floor(k*e),S=Math.floor(P*e),E=Math.ceil(e),b=Math.ceil(e);s.fillStyle=R,s.fillRect(T,S,E,b),f&&(s.strokeStyle="rgba(0, 0, 0, 0.15)",s.lineWidth=1,s.strokeRect(T+.5,S+.5,E-1,b-1))}const u=s.getImageData(0,0,t,a).data,{indexedPixels:y,palette:i}=this.quantizeFrame(u);M.addFrame(0,0,t,a,y,{palette:i,delay:Math.round(l[m]/10)}),await new Promise(d=>setTimeout(d,0))}const x=w.slice(0,M.end());return new Blob([x],{type:"image/gif"})}static quantizeFrame(n){const h=new Map,r=[],l=new Array(n.length/4);for(let e=0;e<n.length;e+=4){const p=n[e],f=n[e+1],c=n[e+2];if(n[e+3]<128){const s="0,0,0,0";h.has(s)||(h.set(s,r.length),r.push(0)),l[e/4]=h.get(s);continue}const a=p<<16|f<<8|c,o=`${p},${f},${c}`;if(!h.has(o)){if(r.length>=256){l[e/4]=0;continue}h.set(o,r.length),r.push(a)}l[e/4]=h.get(o)}for(;r.length<2||(r.length&r.length-1)!==0;)r.push(0);return{indexedPixels:l,palette:r}}}export{C as ExportEngine};
