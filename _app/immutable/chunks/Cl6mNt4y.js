import{_ as B}from"./u7-2yxVl.js";import{P as T}from"./CqCubmkE.js";class j{static toSVG(n,h,a,c="transparent",e=!1){let p=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${n} ${h}" shape-rendering="crispEdges">`;if(c!=="transparent"&&(p+=`<rect width="${n}" height="${h}" fill="${c}" />`),e)a.forEach((f,l)=>{if(f===null)return;const t=l%n,r=Math.floor(l/n);p+=`<rect x="${t}" y="${r}" width="1" height="1" fill="${f}" stroke="rgba(0,0,0,0.15)" stroke-width="0.05" />`});else{const f=new Map;for(let l=0;l<a.length;l++){const t=a[l];t!==null&&(f.has(t)||f.set(t,new Set),f.get(t).add(l))}f.forEach((l,t)=>{const r=T.traceCluster(l,n);r&&(p+=`<path d="${r}" fill="${t}" />`)})}return p+="</svg>",p}static async toRaster(n,h,a,c,e="png",p="transparent",f=!1){const l=document.createElement("canvas"),t=Math.max(1,Math.round(n*c)),r=Math.max(1,Math.round(h*c));l.width=t,l.height=r;const s=l.getContext("2d");if(!s)throw new Error("Could not get canvas context");s.imageSmoothingEnabled=!1,p!=="transparent"?(s.fillStyle=p,s.fillRect(0,0,t,r)):e==="jpg"&&(s.fillStyle="#ffffff",s.fillRect(0,0,t,r)),a.forEach((M,$)=>{if(M===null)return;const y=$%n,u=Math.floor($/n),g=Math.floor(y*c),d=Math.floor(u*c),m=Math.ceil(c),i=Math.ceil(c);s.fillStyle=M,s.fillRect(g,d,m,i),f&&(s.strokeStyle="rgba(0, 0, 0, 0.15)",s.lineWidth=1,s.strokeRect(g+.5,d+.5,m-1,i-1))});const o=e==="jpg"?"image/jpeg":`image/${e}`;return l.toDataURL(o,.9)}static toAnimatedSVG(n,h,a,c,e="transparent",p=!1){const f=c.reduce((s,o)=>s+o,0),l=(f/1e3).toFixed(3);let t=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${n} ${h}" shape-rendering="crispEdges">`;e!=="transparent"&&(t+=`<rect width="${n}" height="${h}" fill="${e}" />`);let r=0;return a.forEach((s,o)=>{const M=(r/f*100).toFixed(3),$=c[o],y=((r+$)/f*100).toFixed(3),u=`rupa-frame-${o}`;if(t+=`<g class="${u}" style="opacity: 0; visibility: hidden; animation: ${u} ${l}s step-end infinite;">`,p)s.forEach((g,d)=>{if(g===null)return;const m=d%n,i=Math.floor(d/n);t+=`<rect x="${m}" y="${i}" width="1" height="1" fill="${g}" stroke="rgba(0,0,0,0.15)" stroke-width="0.05" />`});else{const g=new Map;for(let d=0;d<s.length;d++){const m=s[d];m!==null&&(g.has(m)||g.set(m,new Set),g.get(m).add(d))}g.forEach((d,m)=>{const i=T.traceCluster(d,n);i&&(t+=`<path d="${i}" fill="${m}" />`)})}t+="</g>",t+=`<style>
                @keyframes ${u} {
                    0%, ${M}% { opacity: 0; visibility: hidden; }
                    ${M}%, ${y}% { opacity: 1; visibility: visible; }
                    ${y}%, 100% { opacity: 0; visibility: hidden; }
                }
            </style>`,r+=$}),t+="</svg>",t}static async toVideo(n,h,a,c,e,p="webm",f="transparent",l=!1){const t=document.createElement("canvas"),r=Math.round(n*e),s=Math.round(h*e);t.width=r,t.height=s;const o=t.getContext("2d",{alpha:!1});o.imageSmoothingEnabled=!1;const M=p==="mp4"&&MediaRecorder.isTypeSupported("video/mp4;codecs=h264")?"video/mp4;codecs=h264":"video/webm;codecs=vp8",$=t.captureStream(30),y=new MediaRecorder($,{mimeType:M,videoBitsPerSecond:8e6}),u=[];return y.ondataavailable=g=>{g.data.size>0&&u.push(g.data)},new Promise((g,d)=>{y.onstop=()=>{const i=new Blob(u,{type:M});g(i)},y.onerror=i=>d(i),y.start();const m=i=>{o.fillStyle=f==="transparent"?"#ffffff":f,o.fillRect(0,0,r,s);const w=a[i];for(let x=0;x<w.length;x++){const b=w[x];if(b===null)continue;const k=x%n,R=Math.floor(x/n),v=Math.floor(k*e),S=Math.floor(R*e),E=Math.ceil(e),P=Math.ceil(e);o.fillStyle=b,o.fillRect(v,S,E,P),l&&(o.strokeStyle="rgba(0, 0, 0, 0.15)",o.lineWidth=1,o.strokeRect(v+.5,S+.5,E-1,P-1))}};(async()=>{await new Promise(i=>setTimeout(i,200));for(let i=0;i<a.length;i++)m(i),await new Promise(w=>setTimeout(w,c[i]));await new Promise(i=>setTimeout(i,500)),y.stop(),$.getTracks().forEach(i=>i.stop())})()})}static async toGIF(n,h,a,c,e,p="transparent",f=!1){const{GifWriter:l}=await B(async()=>{const{GifWriter:u}=await import("./CHXe66Ai.js");return{GifWriter:u}},[],import.meta.url),t=Math.round(n*e),r=Math.round(h*e),s=document.createElement("canvas");s.width=t,s.height=r;const o=s.getContext("2d",{alpha:!0});o.imageSmoothingEnabled=!1;const M=new Uint8Array(a.length*t*r*2),$=new l(M,t,r,{loop:0});for(let u=0;u<a.length;u++){o.clearRect(0,0,t,r),p!=="transparent"&&(o.fillStyle=p,o.fillRect(0,0,t,r));const g=a[u];for(let w=0;w<g.length;w++){const x=g[w];if(x===null)continue;const b=w%n,k=Math.floor(w/n),R=Math.floor(b*e),v=Math.floor(k*e),S=Math.ceil(e),E=Math.ceil(e);o.fillStyle=x,o.fillRect(R,v,S,E),f&&(o.strokeStyle="rgba(0, 0, 0, 0.15)",o.lineWidth=1,o.strokeRect(R+.5,v+.5,S-1,E-1))}const d=o.getImageData(0,0,t,r).data,{indexedPixels:m,palette:i}=this.quantizeFrame(d);$.addFrame(0,0,t,r,m,{palette:i,delay:Math.round(c[u]/10)}),await new Promise(w=>setTimeout(w,0))}const y=M.slice(0,$.end());return new Blob([y],{type:"image/gif"})}static quantizeFrame(n){const h=new Map,a=[],c=new Array(n.length/4);for(let e=0;e<n.length;e+=4){const p=n[e],f=n[e+1],l=n[e+2];if(n[e+3]<128){const o="0,0,0,0";h.has(o)||(h.set(o,a.length),a.push(0)),c[e/4]=h.get(o);continue}const r=p<<16|f<<8|l,s=`${p},${f},${l}`;if(!h.has(s)){if(a.length>=256){c[e/4]=0;continue}h.set(s,a.length),a.push(r)}c[e/4]=h.get(s)}for(;a.length<2||(a.length&a.length-1)!==0;)a.push(0);return{indexedPixels:c,palette:a}}}export{j as ExportEngine};
