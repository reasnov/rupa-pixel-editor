import{_ as b}from"./u7-2yxVl.js";import{P as S}from"./CQ1G5WxY.js";class B{static toSVG(n,c,o,f="transparent"){let e=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${n} ${c}" shape-rendering="crispEdges">`;f!=="transparent"&&(e+=`<rect width="${n}" height="${c}" fill="${f}" />`);const l=new Map;for(let s=0;s<o.length;s++){const t=o[s];t!==null&&(l.has(t)||l.set(t,new Set),l.get(t).add(s))}return l.forEach((s,t)=>{const i=S.traceCluster(s,n);i&&(e+=`<path d="${i}" fill="${t}" />`)}),e+="</svg>",e}static findCluster(n,c,o,f,e,l){const s=e[c*o+n],t=new Set,i=[[n,c]];for(l[c*o+n]=!0,t.add(c*o+n);i.length>0;){const[r,a]=i.shift(),p=[[r+1,a],[r-1,a],[r,a+1],[r,a-1]];for(const[h,u]of p)if(h>=0&&h<o&&u>=0&&u<f){const g=u*o+h;!l[g]&&e[g]===s&&(l[g]=!0,t.add(g),i.push([h,u]))}}return t}static greedyRectMerge(n,c){const o=[],f=new Set,e=Array.from(n).sort((l,s)=>l-s);for(const l of e){if(f.has(l))continue;const s=l%c,t=Math.floor(l/c);let i=1;for(;n.has(t*c+(s+i))&&!f.has(t*c+(s+i));)i++;let r=1,a=!0;for(;a;){const p=t+r;for(let h=s;h<s+i;h++){const u=p*c+h;if(!n.has(u)||f.has(u)){a=!1;break}}a&&r++}o.push({x:s,y:t,w:i,h:r});for(let p=t;p<t+r;p++)for(let h=s;h<s+i;h++)f.add(p*c+h)}return o}static async toRaster(n,c,o,f,e="png",l="transparent"){const s=document.createElement("canvas"),t=Math.max(1,Math.round(n*f)),i=Math.max(1,Math.round(c*f));s.width=t,s.height=i;const r=s.getContext("2d");if(!r)throw new Error("Could not get canvas context");r.imageSmoothingEnabled=!1,l!=="transparent"?(r.fillStyle=l,r.fillRect(0,0,t,i)):e==="jpg"&&(r.fillStyle="#ffffff",r.fillRect(0,0,t,i)),o.forEach((p,h)=>{if(p===null)return;const u=h%n,g=Math.floor(h/n);r.fillStyle=p,r.fillRect(Math.floor(u*f),Math.floor(g*f),Math.ceil(f),Math.ceil(f))});const a=e==="jpg"?"image/jpeg":`image/${e}`;return s.toDataURL(a,.9)}static toAnimatedSVG(n,c,o,f,e="transparent"){const l=f.reduce((r,a)=>r+a,0),s=(l/1e3).toFixed(3);let t=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${n} ${c}" shape-rendering="crispEdges">`;e!=="transparent"&&(t+=`<rect width="${n}" height="${c}" fill="${e}" />`);let i=0;return o.forEach((r,a)=>{const p=(i/l*100).toFixed(3),h=f[a],u=((i+h)/l*100).toFixed(3),g=`rupa-frame-${a}`;t+=`<g class="${g}" style="opacity: 0; visibility: hidden; animation: ${g} ${s}s step-end infinite;">`;const m=new Map;for(let x=0;x<r.length;x++){const w=r[x];w!==null&&(m.has(w)||m.set(w,new Set),m.get(w).add(x))}m.forEach((x,w)=>{const d=S.traceCluster(x,n);d&&(t+=`<path d="${d}" fill="${w}" />`)}),t+="</g>",t+=`<style>
                @keyframes ${g} {
                    0%, ${p}% { opacity: 0; visibility: hidden; }
                    ${p}%, ${u}% { opacity: 1; visibility: visible; }
                    ${u}%, 100% { opacity: 0; visibility: hidden; }
                }
            </style>`,i+=h}),t+="</svg>",t}static async toVideo(n,c,o,f,e,l="webm",s="transparent"){const t=document.createElement("canvas"),i=Math.round(n*e),r=Math.round(c*e);t.width=i,t.height=r;const a=t.getContext("2d",{alpha:!1});a.imageSmoothingEnabled=!1;const p=l==="mp4"&&MediaRecorder.isTypeSupported("video/mp4;codecs=h264")?"video/mp4;codecs=h264":"video/webm;codecs=vp8",h=t.captureStream(30),u=new MediaRecorder(h,{mimeType:p,videoBitsPerSecond:8e6}),g=[];return u.ondataavailable=m=>{m.data.size>0&&g.push(m.data)},new Promise((m,x)=>{u.onstop=()=>{const d=new Blob(g,{type:p});m(d)},u.onerror=d=>x(d),u.start();const w=d=>{a.fillStyle=s==="transparent"?"#ffffff":s,a.fillRect(0,0,i,r);const y=o[d];for(let M=0;M<y.length;M++){const v=y[M];if(v===null)continue;const $=M%n,E=Math.floor(M/n);a.fillStyle=v,a.fillRect(Math.floor($*e),Math.floor(E*e),Math.ceil(e),Math.ceil(e))}};(async()=>{await new Promise(d=>setTimeout(d,200));for(let d=0;d<o.length;d++)w(d),await new Promise(y=>setTimeout(y,f[d]));await new Promise(d=>setTimeout(d,500)),u.stop(),h.getTracks().forEach(d=>d.stop())})()})}static async toGIF(n,c,o,f,e,l="transparent"){const{GifWriter:s}=await b(async()=>{const{GifWriter:g}=await import("./CHXe66Ai.js");return{GifWriter:g}},[],import.meta.url),t=Math.round(n*e),i=Math.round(c*e),r=document.createElement("canvas");r.width=t,r.height=i;const a=r.getContext("2d",{alpha:!0});a.imageSmoothingEnabled=!1;const p=new Uint8Array(o.length*t*i*2),h=new s(p,t,i,{loop:0});for(let g=0;g<o.length;g++){a.clearRect(0,0,t,i),l!=="transparent"&&(a.fillStyle=l,a.fillRect(0,0,t,i));const m=o[g];for(let y=0;y<m.length;y++){const M=m[y];if(M===null)continue;const v=y%n,$=Math.floor(y/n);a.fillStyle=M,a.fillRect(Math.floor(v*e),Math.floor($*e),Math.ceil(e),Math.ceil(e))}const x=a.getImageData(0,0,t,i).data,{indexedPixels:w,palette:d}=this.quantizeFrame(x);h.addFrame(0,0,t,i,w,{palette:d,delay:Math.round(f[g]/10)}),await new Promise(y=>setTimeout(y,0))}const u=p.slice(0,h.end());return new Blob([u],{type:"image/gif"})}static quantizeFrame(n){const c=new Map,o=[],f=new Array(n.length/4);for(let e=0;e<n.length;e+=4){const l=n[e],s=n[e+1],t=n[e+2];if(n[e+3]<128){const p="0,0,0,0";c.has(p)||(c.set(p,o.length),o.push(0)),f[e/4]=c.get(p);continue}const r=l<<16|s<<8|t,a=`${l},${s},${t}`;if(!c.has(a)){if(o.length>=256){f[e/4]=0;continue}c.set(a,o.length),o.push(r)}f[e/4]=c.get(a)}for(;o.length<2||(o.length&o.length-1)!==0;)o.push(0);return{indexedPixels:f,palette:o}}}export{B as ExportEngine};
