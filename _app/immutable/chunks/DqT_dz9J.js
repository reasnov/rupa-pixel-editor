import{_}from"./B78w-WDr.js";import{C as T,P as W}from"./DehKsGLb.js";class I{static async toSVG(i,p,s,r="transparent",n=!1,u){let d=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${i} ${p}" shape-rendering="crispEdges">`;if(r!=="transparent"&&(d+=`<rect width="${i}" height="${p}" fill="${r}" />`),n)s.forEach((c,g)=>{if(c===0)return;const t=T.uint32ToHex(c),e=g%i,a=Math.floor(g/i);d+=`<rect x="${e}" y="${a}" width="1" height="1" fill="${t}" stroke="rgba(0,0,0,0.15)" stroke-width="0.05" />`}),u&&u(1);else{const c=new Map;for(let t=0;t<s.length;t++){const e=s[t];if(e===0)continue;const a=T.uint32ToHex(e);c.has(a)||c.set(a,new Set),c.get(a).add(t)}const g=Array.from(c.keys());for(let t=0;t<g.length;t++){const e=g[t],a=c.get(e),o=W.traceCluster(a,i);o&&(d+=`<path d="${o}" fill="${e}" />`),u&&u((t+1)/g.length),await new Promise(y=>setTimeout(y,0))}}return d+="</svg>",d}static async toRaster(i,p,s,r,n="png",u="transparent",d=!1){const c=document.createElement("canvas"),g=Math.max(1,Math.round(i*r)),t=Math.max(1,Math.round(p*r));c.width=g,c.height=t;const e=c.getContext("2d");if(!e)throw new Error("Could not get canvas context");e.imageSmoothingEnabled=!1,u!=="transparent"?(e.fillStyle=u,e.fillRect(0,0,g,t)):n==="jpg"&&(e.fillStyle="#ffffff",e.fillRect(0,0,g,t)),s.forEach((o,y)=>{if(o===0)return;const M=T.uint32ToHex(o),v=y%i,x=Math.floor(y/i),l=Math.floor(v*r),h=Math.floor(x*r),w=Math.ceil(r),m=Math.ceil(r);e.fillStyle=M,e.fillRect(l,h,w,m),d&&(e.strokeStyle="rgba(0, 0, 0, 0.15)",e.lineWidth=1,e.strokeRect(l+.5,h+.5,w-1,m-1))});const a=n==="jpg"?"image/jpeg":`image/${n}`;return c.toDataURL(a,.9)}static async toAnimatedSVG(i,p,s,r,n="transparent",u=!1,d){const c=r.reduce((a,o)=>a+o,0),g=(c/1e3).toFixed(3);let t=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${i} ${p}" shape-rendering="crispEdges">`;n!=="transparent"&&(t+=`<rect width="${i}" height="${p}" fill="${n}" />`);let e=0;for(let a=0;a<s.length;a++){const o=s[a],y=(e/c*100).toFixed(3),M=r[a],v=((e+M)/c*100).toFixed(3),x=`rupa-frame-${a}`;if(t+=`<g class="${x}" style="opacity: 0; visibility: hidden; display: none; animation: ${x} ${g}s step-end infinite;">`,u)o.forEach((l,h)=>{if(l===0)return;const w=T.uint32ToHex(l),m=h%i,f=Math.floor(h/i);t+=`<rect x="${m}" y="${f}" width="1" height="1" fill="${w}" stroke="rgba(0,0,0,0.15)" stroke-width="0.05" />`});else{const l=new Map;for(let h=0;h<o.length;h++){const w=o[h];if(w===0)continue;const m=T.uint32ToHex(w);l.has(m)||l.set(m,new Set),l.get(m).add(h)}l.forEach((h,w)=>{const m=W.traceCluster(h,i);m&&(t+=`<path d="${m}" fill="${w}" />`)})}t+="</g>",t+=`<style>
                @keyframes ${x} {
                    0%, ${y}% { opacity: 0; visibility: hidden; display: none; }
                    ${y}%, ${v}% { opacity: 1; visibility: visible; display: block; }
                    ${v}%, 100% { opacity: 0; visibility: hidden; display: none; }
                }
            </style>`,e+=M,d&&d((a+1)/s.length),await new Promise(l=>setTimeout(l,0))}return t+="</svg>",t}static async toVideo(i,p,s,r,n,u="webm",d="transparent",c=!1,g){const t=document.createElement("canvas"),e=Math.round(i*n),a=Math.round(p*n);t.width=e,t.height=a,t.style.position="fixed",t.style.left="-10000px",t.style.top="-10000px",document.body.appendChild(t);const o=t.getContext("2d",{alpha:!1});o.imageSmoothingEnabled=!1;const y=u==="mp4"&&MediaRecorder.isTypeSupported("video/mp4;codecs=h264")?"video/mp4;codecs=h264":"video/webm;codecs=vp8",M=t.captureStream(0),v=M.getVideoTracks()[0],x=new MediaRecorder(M,{mimeType:y,videoBitsPerSecond:8e6}),l=[];return x.ondataavailable=h=>{h.data.size>0&&l.push(h.data)},new Promise((h,w)=>{x.onstop=()=>{document.body.removeChild(t);const f=new Blob(l,{type:y});h(f)},x.onerror=f=>{document.body.removeChild(t),w(f)},x.start();const m=f=>{o.fillStyle=d==="transparent"?"#ffffff":d,o.fillRect(0,0,e,a);const S=s[f];for(let b=0;b<S.length;b++){const $=S[b];if($===0)continue;const F=T.uint32ToHex($),P=b%i,C=Math.floor(b/i),H=Math.floor(P*n),k=Math.floor(C*n),E=Math.ceil(n),R=Math.ceil(n);o.fillStyle=F,o.fillRect(H,k,E,R),c&&(o.strokeStyle="rgba(0, 0, 0, 0.15)",o.lineWidth=1,o.strokeRect(H+.5,k+.5,E-1,R-1))}o.getImageData(0,0,1,1)};(async()=>{await new Promise(f=>setTimeout(f,200));for(let f=0;f<s.length;f++)m(f),v&&v.requestFrame&&v.requestFrame(),await new Promise(S=>setTimeout(S,r[f])),g&&g((f+1)/s.length);await new Promise(f=>setTimeout(f,500)),x.stop(),M.getTracks().forEach(f=>f.stop())})()})}static async toGIF(i,p,s,r,n,u="transparent",d=!1,c){const{GifWriter:g}=await _(async()=>{const{GifWriter:l}=await import("./CHXe66Ai.js");return{GifWriter:l}},[],import.meta.url),t=Math.round(i*n),e=Math.round(p*n),a=document.createElement("canvas");a.width=t,a.height=e;const o=a.getContext("2d",{alpha:!0});o.imageSmoothingEnabled=!1;const y=new Uint8Array(s.length*t*e*2),M=new g(y,t,e,{loop:0});let v=0;for(let l=0;l<s.length;l++){o.clearRect(0,0,t,e),u!=="transparent"&&(o.fillStyle=u,o.fillRect(0,0,t,e));const h=s[l];for(let $=0;$<h.length;$++){const F=h[$];if(F===0)continue;const P=T.uint32ToHex(F),C=$%i,H=Math.floor($/i),k=Math.floor(C*n),E=Math.floor(H*n),R=Math.ceil(n),B=Math.ceil(n);o.fillStyle=P,o.fillRect(k,E,R,B),d&&(o.strokeStyle="rgba(0, 0, 0, 0.15)",o.lineWidth=1,o.strokeRect(k+.5,E+.5,R-1,B-1))}const w=o.getImageData(0,0,t,e).data,{indexedPixels:m,palette:f}=this.quantizeFrame(w),S=r[l]+v,b=Math.max(1,Math.round(S/10));v=S-b*10,M.addFrame(0,0,t,e,m,{palette:f,delay:b}),c&&c((l+1)/s.length),await new Promise($=>setTimeout($,0))}const x=y.slice(0,M.end());return new Blob([x],{type:"image/gif"})}static quantizeFrame(i){const p=new Map,s=[],r=new Array(i.length/4);for(let n=0;n<i.length;n+=4){const u=i[n],d=i[n+1],c=i[n+2];if(i[n+3]<128){const a="0,0,0,0";p.has(a)||(p.set(a,s.length),s.push(0)),r[n/4]=p.get(a);continue}const t=u<<16|d<<8|c,e=`${u},${d},${c}`;if(!p.has(e)){if(s.length>=256){r[n/4]=0;continue}p.set(e,s.length),s.push(t)}r[n/4]=p.get(e)}for(;s.length<2||(s.length&s.length-1)!==0;)s.push(0);return{indexedPixels:r,palette:s}}}export{I as ExportEngine};
