class p{static toSVG(n,r,f,l="transparent"){let x=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${n} ${r}" shape-rendering="crispEdges">`;l!=="transparent"&&(x+=`<rect width="${n}" height="${r}" fill="${l}" />`);const c=new Array(f.length).fill(!1);for(let e=0;e<r;e++)for(let s=0;s<n;s++){const t=e*n+s,a=f[t];if(a===null||c[t])continue;const i=this.findCluster(s,e,n,r,f,c);this.greedyRectMerge(i,n).forEach(o=>{x+=`<rect x="${o.x}" y="${o.y}" width="${o.w}" height="${o.h}" fill="${a}" />`})}return x+="</svg>",x}static findCluster(n,r,f,l,x,c){const e=x[r*f+n],s=new Set,t=[[n,r]];for(c[r*f+n]=!0,s.add(r*f+n);t.length>0;){const[a,i]=t.shift(),h=[[a+1,i],[a-1,i],[a,i+1],[a,i-1]];for(const[o,u]of h)if(o>=0&&o<f&&u>=0&&u<l){const g=u*f+o;!c[g]&&x[g]===e&&(c[g]=!0,s.add(g),t.push([o,u]))}}return s}static greedyRectMerge(n,r){const f=[],l=new Set,x=Array.from(n).sort((c,e)=>c-e);for(const c of x){if(l.has(c))continue;const e=c%r,s=Math.floor(c/r);let t=1;for(;n.has(s*r+(e+t))&&!l.has(s*r+(e+t));)t++;let a=1,i=!0;for(;i;){const h=s+a;for(let o=e;o<e+t;o++){const u=h*r+o;if(!n.has(u)||l.has(u)){i=!1;break}}i&&a++}f.push({x:e,y:s,w:t,h:a});for(let h=s;h<s+a;h++)for(let o=e;o<e+t;o++)l.add(h*r+o)}return f}static async toPNG(n,r,f,l,x="transparent"){const c=document.createElement("canvas"),e=Math.max(1,Math.round(n*l)),s=Math.max(1,Math.round(r*l));c.width=e,c.height=s;const t=c.getContext("2d");if(!t)throw new Error("Could not get canvas context");return t.imageSmoothingEnabled=!1,x!=="transparent"&&(t.fillStyle=x,t.fillRect(0,0,e,s)),f.forEach((a,i)=>{if(a===null)return;const h=i%n,o=Math.floor(i/n);t.fillStyle=a,t.fillRect(Math.floor(h*l),Math.floor(o*l),Math.ceil(l),Math.ceil(l))}),c.toDataURL("image/png")}}export{p as ExportEngine};
